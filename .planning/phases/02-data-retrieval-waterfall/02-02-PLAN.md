---
phase: 02-data-retrieval-waterfall
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/nyc_apis.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "GeoSearch API resolves NYC addresses to BBL and BIN"
    - "LL84 API fetches live energy data by BIN including all use-type square footages"
    - "PLUTO API fetches building structure data including address as fallback"
    - "All API calls have retry logic with exponential backoff"
    - "Multiple BINs per BBL handled correctly (LIKE query for LL84)"
  artifacts:
    - path: "lib/nyc_apis.py"
      provides: "GeoSearch, LL84, and PLUTO API clients with retry logic"
      exports: ["call_geosearch_api", "call_ll84_api", "call_pluto_api", "LL84_FIELD_MAP"]
    - path: "requirements.txt"
      provides: "Updated dependencies with requests and sodapy"
      contains: "sodapy"
  key_links:
    - from: "lib/nyc_apis.py"
      to: "https://geosearch.planninglabs.nyc/v2/search"
      via: "requests with retry session"
      pattern: "geosearch.*planninglabs"
    - from: "lib/nyc_apis.py"
      to: "https://data.cityofnewyork.us/resource/5zyy-y8am"
      via: "sodapy Socrata client"
      pattern: "5zyy-y8am"
    - from: "lib/nyc_apis.py"
      to: "https://data.cityofnewyork.us/resource/64uk-42ks"
      via: "sodapy Socrata client"
      pattern: "64uk-42ks"
---

<objective>
Create NYC Open Data API clients for GeoSearch, LL84, and PLUTO with retry logic and field mapping.

Purpose: The waterfall pipeline needs to call three external APIs — GeoSearch for address-to-BBL resolution, LL84 for live energy benchmarking data, and PLUTO for building structure fallback. This plan creates a robust API client module with retry logic, proper field mapping, and handling for known quirks (semicolon-delimited BINs, fuzzy GeoSearch matching).

Output: `lib/nyc_apis.py` with three API client functions and a comprehensive LL84 field mapping dict. Updated `requirements.txt` with requests and sodapy.
</objective>

<execution_context>
@C:\Users\minke\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\minke\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-retrieval-waterfall/02-RESEARCH.md
@.planning/codebase/INTEGRATIONS.md
@lib/validators.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add requests and sodapy to requirements.txt</name>
  <files>requirements.txt</files>
  <action>
Add to existing requirements.txt (preserve existing entries and the Python 3.14 comment at top):
- `requests>=2.31`
- `sodapy>=2.2.0`

Do NOT remove any existing dependencies. Append to the end of the file.

Then run `pip install requests>=2.31 sodapy>=2.2.0` to install the new dependencies.
  </action>
  <verify>Run `python -c "import requests; import sodapy; print(f'requests {requests.__version__}, sodapy OK')"` — should print versions without errors.</verify>
  <done>requirements.txt has requests and sodapy listed. Both importable in Python.</done>
</task>

<task type="auto">
  <name>Task 2: Create lib/nyc_apis.py with GeoSearch, LL84, and PLUTO API clients</name>
  <files>lib/nyc_apis.py</files>
  <action>
Create `lib/nyc_apis.py` with these components:

**1. Retry session factory:**
```python
def _create_retry_session() -> requests.Session:
```
- Use `urllib3.util.retry.Retry` with `total=3`, `backoff_factor=1`, `status_forcelist=[429, 500, 502, 503, 504]`
- Mount `HTTPAdapter(max_retries=retry_strategy)` on both http:// and https://
- Set default timeout of 15 seconds

**2. `call_geosearch_api(address: str) -> Optional[Dict[str, Any]]`:**
- Endpoint: `https://geosearch.planninglabs.nyc/v2/search`
- Parameter: `text={address}`
- Extract from response:
  - BBL: `features[0].properties.addendum.pad.bbl`
  - BIN: `features[0].properties.addendum.pad.bin`
  - Confidence: `features[0].properties.confidence`
  - Label: `features[0].properties.label`
- Return None if no features or confidence < 0.8 (per research pitfall #4)
- Return dict with keys: `bbl`, `bin`, `confidence`, `label`, `address`
- Log warnings for low-confidence matches
- Catch requests.RequestException and return None (don't crash)

**3. `call_ll84_api(bin_number: str, app_token: Optional[str] = None) -> Optional[Dict[str, Any]]`:**
- Use sodapy.Socrata client with `data.cityofnewyork.us`, `app_token`, `timeout=30`
- Dataset ID: `5zyy-y8am`
- Query: `where=f"nyc_building_identification LIKE '%{bin_number}%'"` (handles semicolon-delimited BINs per pitfall #2)
- Order: `last_modified_date_property DESC`
- Limit: 1
- Map ALL returned fields to internal names using `LL84_FIELD_MAP` (see below)
- Return dict with mapped field names matching Building_Metrics column names
- Return None if no results
- Close sodapy client in finally block
- Catch exceptions and return None (don't crash)

**4. `LL84_FIELD_MAP` dict** mapping Socrata API field names to internal Building_Metrics column names:

Base fields:
- `"year_built"` -> `"year_built"`
- `"largest_property_use_type_self_selected"` -> `"property_type"`
- `"property_gfa_self_reported_ft"` -> `"gfa"`
- `"electricity_use_grid_purchase_kwh"` -> `"electricity_kwh"`
- `"natural_gas_use_kbtu"` -> `"natural_gas_kbtu"`
- `"fuel_oil_2_use_kbtu"` -> `"fuel_oil_kbtu"`
- `"district_steam_use_kbtu"` -> `"steam_kbtu"`
- `"site_energy_use_intensity_kbtu_ft"` -> `"site_eui"`
- `"energy_star_score"` -> `"energy_star_score"`

Use-type square footage fields: Map each LL84 API field name to the corresponding `_sqft` column name in Building_Metrics. The LL84 API uses field names like `adult_education_gross_floor_area_ft` for use-type sqft fields.

IMPORTANT: The exact LL84 Socrata field names for the 42+ use-type sqft columns need to be discovered. At the start of this task, query the LL84 dataset metadata to find exact field names:
```python
from sodapy import Socrata
client = Socrata("data.cityofnewyork.us", None, timeout=30)
metadata = client.get_metadata("5zyy-y8am")
# Look for columns containing "floor_area" or "gross_floor" in the name
for col in metadata['columns']:
    if 'floor_area' in col['fieldName'].lower() or 'gross_floor' in col['fieldName'].lower():
        print(f"  {col['fieldName']} -> {col['name']}")
```
Use this metadata query to build the complete field map. Document the actual API field names as comments in the code.

The mapping function should convert Socrata string values to appropriate Python types (NUMERIC fields as float, INTEGER fields as int, TEXT as str). Handle None/empty values gracefully.

**5. `call_pluto_api(bbl: str, app_token: Optional[str] = None) -> Optional[Dict[str, Any]]`:**
- Validate BBL is 10-digit numeric using `validators.validate_bbl()` (import from lib.validators)
- Use sodapy.Socrata client with `data.cityofnewyork.us`, `app_token`, `timeout=30`
- Dataset ID: `64uk-42ks`
- Query: `where=f"bbl='{bbl}'"` (10-digit numeric, no dashes)
- Limit: 1
- Map returned fields to internal names:
  - `"yearbuilt"` -> `"year_built"` (int)
  - `"numfloors"` -> `"num_floors"` (int)
  - `"bldgarea"` -> `"gfa"` (float)
  - `"ownername"` -> `"owner_name"` (str)
  - `"address"` -> `"address"` (str) -- CRITICAL: Map the PLUTO `address` field so the waterfall can use it for GeoSearch fallback when BBL is not in LL97. The PLUTO dataset `64uk-42ks` has an `address` field containing the street address of the building.
  - `"zipcode"` -> `"zip_code"` (str) -- Also map zipcode for completeness
- Return None if no results
- Close sodapy client in finally block

**6. `_safe_float(value) -> Optional[float]` and `_safe_int(value) -> Optional[int]` helper functions** for safely converting API string responses to numeric types. Return None for empty strings, None values, or conversion errors.

**7. App token loading:** Create a `_get_app_token() -> Optional[str]` function that checks:
  1. `os.environ.get("NYC_OPEN_DATA_APP_TOKEN")`
  2. Try `st.secrets.get("NYC_OPEN_DATA_APP_TOKEN")` (wrapped in try/except for non-Streamlit contexts)
  3. Return None if not found (unauthenticated requests still work, just slower rate limits)

All three API functions should accept an optional `app_token` parameter, defaulting to `_get_app_token()` if not provided.

Add logging using Python's `logging` module (not print statements). Set up logger as `logger = logging.getLogger(__name__)`. Log API calls at INFO level, errors at ERROR level, low-confidence GeoSearch at WARNING level.
  </action>
  <verify>
First, verify imports work: `python -c "from lib.nyc_apis import call_geosearch_api, call_ll84_api, call_pluto_api, LL84_FIELD_MAP; print(f'Field map entries: {len(LL84_FIELD_MAP)}'); print('Import OK')"`

Then test GeoSearch with a known address: `python -c "from lib.nyc_apis import call_geosearch_api; result = call_geosearch_api('1 Centre Street, New York, NY'); print(f'BBL: {result[\"bbl\"]}, BIN: {result[\"bin\"]}') if result else print('No result')"` — should return a Manhattan BBL starting with '1'.

Then test LL84 with a known BIN: `python -c "from lib.nyc_apis import call_ll84_api; result = call_ll84_api('1001389'); print(f'Property type: {result.get(\"property_type\", \"N/A\")}') if result else print('No LL84 data')"` — should return energy data (BIN 1001389 is 1 Centre Street).

Then test PLUTO (including address field): `python -c "from lib.nyc_apis import call_pluto_api; result = call_pluto_api('1001580001'); print(f'Year built: {result.get(\"year_built\", \"N/A\")}, Address: {result.get(\"address\", \"N/A\")}') if result else print('No PLUTO data')"` — should return building data including a street address.
  </verify>
  <done>
  - lib/nyc_apis.py exists with call_geosearch_api, call_ll84_api, call_pluto_api, and LL84_FIELD_MAP
  - GeoSearch resolves addresses to BBL/BIN with confidence check
  - LL84 API returns energy metrics and use-type sqft fields with proper field mapping
  - PLUTO API returns building structure data including address and zip_code (critical for GeoSearch fallback chain)
  - All API calls have retry logic (3 retries, exponential backoff)
  - Multiple BINs handled via LIKE query in LL84
  - API responses converted to proper Python types (float/int/str)
  - Module works without Streamlit (graceful fallback for app token loading)
  </done>
</task>

</tasks>

<verification>
- `python -c "from lib.nyc_apis import call_geosearch_api, call_ll84_api, call_pluto_api, LL84_FIELD_MAP"` succeeds
- GeoSearch returns BBL/BIN for known NYC address
- LL84 returns energy data with use-type sqft fields for known BIN
- PLUTO returns year_built/gfa/address for known BBL (address field must be present)
- LL84_FIELD_MAP has entries for base energy fields + use-type sqft fields
- Retry logic configured (3 retries, backoff_factor=1, 429/5xx status codes)
</verification>

<success_criteria>
- Three API client functions work against live NYC Open Data endpoints
- LL84 field mapping covers all use-type square footage fields discovered from metadata
- GeoSearch confidence filtering prevents low-quality matches
- PLUTO validates BBL format before querying and returns address field
- All functions return None on failure (no exceptions bubble up)
- requirements.txt updated with requests and sodapy
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-retrieval-waterfall/02-02-SUMMARY.md`
</output>
